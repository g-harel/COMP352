Node List :

	toString :		toString() {
						loop through all array pos until last {
							print value
						}
					}
					complexity:	1) O(n)
							2) O(n) (no array manipulation)


	fits :			fits() {
						return true if number of values + 1 isn't 80% of total
					}
					complexity:	1) O(1)
								2) O(1) (no array manipulation)


	expand :		expand() {
						if rule is double, return new array with length *2
						else, return new array with length +10
					}
					complexity:	1) O(1)
								2) O(1) (no array manipulation)


	first :			first() {
						if array is non empty, return Position at index 0
						else, exception
					}
					complexity:	1) O(1)
								2) O(1) (no array manipulation)


	last :			last() {
						if array is non empty, return Position at last index
						else, exception
					}
					complexity:	1) O(1)
								2) O(1) (no array manipulation)


	prev :			prev() {
						for all values in array {
							if Position is found, return the one before it
						}
						throw exception if not found
					}
					complexity:	1) O(n)
								2) O(n) (no array manipulation)


	next :			next() {
						for all values in array {
							if Position is found, return the one after it
						}
						throw exception if not found
					}
					complexity:	1) O(n)
								2) O(n) (no array manipulation)


	set :			set() {
						for all values in array {
							if Position is found, replace it with a new one
						}
						throw exception if not found
					}
					complexity:	1) O(n)
								2) O(n) (no array manipulation)


	addFirst :		addFirst() {
						check if array can fit one more value (fits()) {
							create new array of same size as current
						} else {
							create a new array using expand()
						}
						set index 0 of new array to a new Position
						for all values in original array {
							place the value to index +1 in new array
						}
						return the new Position
					}
					complexity:	1) O(n)
								2) O(n) (worst case, array size *= 2)


	addLast :		addLast() {
						check if array can't fit one more value (fits()) {
							create new array using expand()
							for all values in original array {
								place the value in same index in new array
							}
						}
						set the last element +1 to a new Position
						return the new Position
					}
					complexity:	1) O(1)
								2) O(n)


	addBefore :		addBefore() {
						check if array can fit one more value (fits()) {
							create new array of same size as current
						} else {
							create a new array using expand()
						}
						for all values in original array {
							if the Position is found, also add the new Position
							place the value in the same index in original array
						}
						if Position is not found, exception
						return the new Position
					}
					complexity:	1) O(n)
								2) O(n)


	addAfter :		addAfter() {
						check if array can fit one more value (fits()) {
							create new array of same size as current
						} else {
							create a new array using expand()
						}
						for all values in original array {
							place the value in the same index in original array
							if the Position is found, also add the new Position
						}
						if Position is not found, exception
						return the new Position
					}
					complexity:	1) O(n)
								2) O(n)


	delete :		delete() {
						create new array of the same size as original array
						for all values in original array {
							if the index Position is the one to delete, skip it
							place values of the same index in the new array
						}
						if Position was not found, exception
					}
					complexity:	1) O(n)
								2) O(n)


	swap :			swap() {
						store element of p1
						set element of p1 to element of p2
						set element of p2 to stored value
					}
					complexity:	1) O(1)
								2) O(1) (no array manipulation)


	truncate :		truncate() {
						create new array of values +1 length
						for all values in original array {
							place values of the same index in new array
						}
					}
					complexity:	1) O(n)
								2) O(n)


	setExpRule :	setExpansionRule() {
						if rule is char is recognized, change it
					}
					complexity:	1) O(1)
								2) O(1) (no array manipulation)
